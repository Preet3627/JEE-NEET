<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <!-- Updated CSP to allow Google Sign-In popups and scripts more freely -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https://accounts.google.com https://apis.google.com https://www.gstatic.com; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://accounts.google.com https://apis.google.com https://www.gstatic.com; style-src 'self' 'unsafe-inline' https://accounts.google.com; img-src 'self' data: https: blob:; connect-src 'self' https://*.googleapis.com https://accounts.google.com https://apis.google.com https://www.gstatic.com https://ponsrischool.in https://nc.ponsrischool.in; frame-src 'self' https://accounts.google.com https://content.googleapis.com blob:; media-src 'self' https://nc.ponsrischool.in blob:;">
    <link rel="icon" type="image/png" href="https://ponsrischool.in/wp-content/uploads/2025/11/Gemini_Generated_Image_ujvnj5ujvnj5ujvn.png" crossorigin="anonymous" />
    <link rel="manifest" href="/manifest.json">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#000000">
    <title>JEE Scheduler Pro | AI-Powered Study Planner</title>
    <meta name="description" content="An AI-powered, multilingual weekly scheduler for JEE aspirants, featuring a clean, futuristic UI to optimize study sessions, track performance, and collaborate with peers." />
    <meta name="keywords" content="JEE, IIT-JEE, study planner, AI scheduler, JEE preparation, student dashboard, offline PWA, Google Calendar sync, mock test analysis" />

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "SoftwareApplication",
      "name": "JEE Scheduler Pro",
      "applicationCategory": "EducationalApplication",
      "operatingSystem": "Web",
      "description": "An AI-powered, multilingual weekly scheduler for JEE aspirants, featuring a clean, futuristic UI to optimize study sessions, track performance, and collaborate with peers.",
      "url": "https://jee.ponsrischool.in",
      "offers": {
        "@type": "Offer",
        "price": "0"
      }
    }
    </script>
    
    <style>
      :root {
        --gradient-cyan: #0891b2;
        --gradient-purple: #7c3aed;
        
        /* Default Theme */
        --main-bg: #02040a;
        --glass-bg: rgba(17, 24, 39, 0.5);
        --glass-border: rgba(55, 65, 81, 0.4);
        --body-bg-image: radial-gradient(ellipse at top, #111827, #02040a 70%);
        --font-sans: -apple-system, BlinkMacSystemFont, "SF Pro Display", "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        --modal-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        --modal-border-radius: 0.75rem;

        /* Customizable Accent Color */
        --accent-color: var(--gradient-cyan);

        /* iOS Safe Area Insets */
        --safe-area-inset-top: env(safe-area-inset-top);
        --safe-area-inset-right: env(safe-area-inset-right);
        --safe-area-inset-bottom: env(safe-area-inset-bottom);
        --safe-area-inset-left: env(safe-area-inset-left);
      }

      /* Liquid Glass Theme (MacOS Style) */
      .theme-liquid-glass {
        --main-bg: #000000;
        --glass-bg: rgba(30, 30, 35, 0.65);
        --glass-border: rgba(255, 255, 255, 0.12);
        --body-bg-image: url('https://images.unsplash.com/photo-1550684848-fac1c5b4e853?q=80&w=2070&auto=format&fit=crop'); /* Abstract Liquid BG */
        --font-sans: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        --modal-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        --modal-border-radius: 1.25rem;
      }
      
      .theme-liquid-glass .modal-content-enter,
      .theme-liquid-glass .modal-content-exit,
      .theme-liquid-glass .modal-content-exit-active,
      .theme-liquid-glass .modal-content-enter-active {
        border-radius: var(--modal-border-radius);
      }

      .theme-midnight {
        --main-bg: #000000;
        --glass-bg: rgba(10, 10, 10, 0.8);
        --glass-border: rgba(40, 40, 40, 0.8);
        --body-bg-image: radial-gradient(at 50% 10%, hsla(240, 100%, 5%, 1) 0px, #000000 80%);
      }

      body {
        background-color: var(--main-bg);
        background-image: var(--body-bg-image);
        background-attachment: fixed;
        background-size: cover;
        background-position: center;
        font-family: var(--font-sans);
        -webkit-font-smoothing: antialiased;
        overflow-x: hidden; /* Prevent horizontal scroll during transitions */
      }

      /* Navigation Transitions */
      .animate-slide-in-right {
        animation: slideInRight 0.3s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
      }
      
      .animate-slide-in-left {
        animation: slideInLeft 0.3s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
      }

      @keyframes slideInRight {
        from { opacity: 0; transform: translateX(20px); }
        to { opacity: 1; transform: translateX(0); }
      }

      @keyframes slideInLeft {
        from { opacity: 0; transform: translateX(-20px); }
        to { opacity: 1; transform: translateX(0); }
      }

      /* MacOS Traffic Lights */
      .traffic-light {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        display: inline-block;
        margin-right: 8px;
        position: relative;
        transition: transform 0.1s;
      }
      .traffic-light:hover { transform: scale(1.1); }
      .traffic-red { background-color: #FF5F56; border: 1px solid #E0443E; }
      .traffic-yellow { background-color: #FFBD2E; border: 1px solid #DEA123; }
      .traffic-green { background-color: #27C93F; border: 1px solid #1AAB29; }
      
      /* Hover icons inside traffic lights */
      .traffic-light::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        opacity: 0;
        transition: opacity 0.1s;
        font-size: 8px;
        color: rgba(0,0,0,0.6);
        font-weight: bold;
      }
      .window-controls:hover .traffic-light::after { opacity: 1; }
      .window-controls:hover .traffic-red::after { content: 'Ã—'; }
      .window-controls:hover .traffic-yellow::after { content: '-'; }
      .window-controls:hover .traffic-green::after { content: '+'; }


      /* Widget Specifics */
      .widget-container {
        transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
      }
      .widget-minimized {
        height: 48px !important;
        overflow: hidden;
      }

      /* Scrollbar */
      ::-webkit-scrollbar { width: 6px; }
      ::-webkit-scrollbar-track { background: transparent; }
      ::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.1); border-radius: 3px; }
      ::-webkit-scrollbar-thumb:hover { background: rgba(255, 255, 255, 0.3); }

      /* Flashcard Flip */
      .flashcard-container {
        display: grid;
        perspective: 1000px;
        min-height: 150px;
      }
      .flashcard-inner {
        position: relative;
        width: 100%;
        transition: transform 0.6s;
        transform-style: preserve-3d;
        grid-area: 1 / 1 / 2 / 2;
      }
      .flashcard-flipped { transform: rotateY(180deg); }
      .flashcard-front, .flashcard-back {
        width: 100%;
        height: 100%;
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 1rem;
        border-radius: 0.75rem;
        text-align: center;
        grid-area: 1 / 1 / 2 / 2;
        position: absolute;
        top: 0;
        left: 0;
      }
      .flashcard-front { z-index: 2; transform: rotateY(0deg); }
      .flashcard-back { transform: rotateY(180deg); }

      /* Animations */
      @keyframes spin-slow { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
      .animate-spin-slow { animation: spin-slow 12s linear infinite; }
      
      @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
      @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
      @keyframes scaleIn { from { transform: scale(0.95); opacity: 0; } to { transform: scale(1); opacity: 1; } }
      @keyframes scaleOut { from { transform: scale(1); opacity: 1; } to { transform: scale(0.95); opacity: 0; } }
      
      .modal-enter { animation: fadeIn 0.3s cubic-bezier(0.16, 1, 0.3, 1) forwards; }
      .modal-content-enter { animation: scaleIn 0.3s cubic-bezier(0.16, 1, 0.3, 1) forwards; }
      .modal-exit { animation: fadeOut 0.3s cubic-bezier(0.16, 1, 0.3, 1) forwards; }
      .modal-content-exit { animation: scaleOut 0.3s cubic-bezier(0.16, 1, 0.3, 1) forwards; }

      /* Genie Animation (MacOS Style) */
      @keyframes genie-in {
        0% { clip-path: circle(0% at var(--clip-origin-x) var(--clip-origin-y)); opacity: 0; }
        100% { clip-path: circle(150% at var(--clip-origin-x) var(--clip-origin-y)); opacity: 1; }
      }
      @keyframes genie-out {
        0% { clip-path: circle(150% at var(--clip-origin-x) var(--clip-origin-y)); opacity: 1; }
        100% { clip-path: circle(0% at var(--clip-origin-x) var(--clip-origin-y)); opacity: 0; }
      }
      .genie-in { animation: genie-in 0.5s cubic-bezier(0.65, 0, 0.35, 1) forwards; }
      .genie-out { animation: genie-out 0.5s cubic-bezier(0.65, 0, 0.35, 1) forwards; }

      .no-blur .backdrop-blur-sm, .no-blur .backdrop-blur-md, .no-blur .backdrop-blur-lg {
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
      }
    </style>
<script type="importmap">
{
  "imports": {
    "crypto": "https://aistudiocdn.com/crypto@^1.0.1",
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.30.0",
    "@vitejs/plugin-react": "https://aistudiocdn.com/@vitejs/plugin-react@^5.1.1",
    "express": "https://aistudiocdn.com/express@^5.2.1",
    "cors": "https://aistudiocdn.com/cors@^2.8.5",
    "vite": "https://aistudiocdn.com/vite@^7.2.6",
    "path": "https://aistudiocdn.com/path@^0.12.7",
    "react/": "https://aistudiocdn.com/react@^19.2.1/",
    "react": "https://aistudiocdn.com/react@^19.2.1",
    "dotenv": "https://aistudiocdn.com/dotenv@^17.2.3",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.1/",
    "google-auth-library": "https://aistudiocdn.com/google-auth-library@^10.5.0",
    "bcryptjs": "https://aistudiocdn.com/bcryptjs@^2.4.3",
    "vite-plugin-pwa": "https://aistudiocdn.com/vite-plugin-pwa@^1.2.0",
    "url": "https://aistudiocdn.com/url@^0.11.4",
    "jsonwebtoken": "https://aistudiocdn.com/jsonwebtoken@^9.0.2",
    "mysql2/": "https://aistudiocdn.com/mysql2@^3.15.3/",
    "webdav": "https://aistudiocdn.com/webdav@^5.8.0",
    "music-metadata-browser": "https://aistudiocdn.com/music-metadata-browser@^2.5.11",
    "workbox-precaching": "https://aistudiocdn.com/workbox-precaching@^7.4.0",
    "nodemailer": "https://aistudiocdn.com/nodemailer@^7.0.11",
    "vite-plugin-node-polyfills": "https://aistudiocdn.com/vite-plugin-node-polyfills@^0.24.0"
  }
}
</script>
</head>
  <body>
    <div id="root"></div>
    <script type="module" src="/index.tsx"></script>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
  </body>
</html>--- START OF FILE App.tsx ---

import React, { useState, useEffect, useCallback, useRef, useMemo } from 'react';
import { useAuth } from './context/AuthContext';
import { StudentData, ScheduleItem, StudySession, Config, ResultData, ExamData, DoubtData, HomeworkData, PracticeQuestion, FlashcardDeck, Flashcard, StudyMaterialItem } from './types';
import { studentDatabase } from './data/mockData';
import { api } from './api/apiService';

import Header from './components/Header';
import StudentDashboard from './components/StudentDashboard';
import TeacherDashboard from './components/TeacherDashboard';
import AuthScreen from './screens/AuthScreen';
import BackendOfflineScreen from './components/BackendOfflineScreen';
import ConfigurationErrorScreen from './components/ConfigurationErrorScreen';
import { exportCalendar } from './utils/calendar';
import * as gcal from './utils/googleCalendar';
import * as gdrive from './utils/googleDrive';
import * as auth from './utils/googleAuth';
import ExamTypeSelectionModal from './components/ExamTypeSelectionModal';
import { useMusicPlayer } from './context/MusicPlayerContext';
import FullScreenMusicPlayer from './components/FullScreenMusicPlayer';
import PersistentMusicPlayer from './components/PersistentMusicPlayer';
import GlobalMusicVisualizer from './components/GlobalMusicVisualizer';
import ProfileModal from './components/ProfileModal';
import AIParserModal from './components/AIParserModal';
import { CustomPracticeModal } from './components/CustomPracticeModal';
import SettingsModal from './components/SettingsModal';
import EditWeaknessesModal from './components/EditWeaknessesModal';
import LogResultModal from './components/LogResultModal';
import EditResultModal from './components/EditResultModal';
import CreateEditExamModal from './components/CreateEditExamModal';
import AIMistakeAnalysisModal from './components/AIMistakeAnalysisModal';
import AIDoubtSolverModal from './components/AIDoubtSolverModal';
import AIChatPopup from './components/AIChatPopup';
import TestReportModal from './components/TestReportModal';
import MoveTasksModal from './components/MoveTasksModal';
import MusicLibraryModal from './components/MusicLibraryModal';
import DeepLinkConfirmationModal from './components/DeepLinkConfirmationModal';
import CreateEditDeckModal from './components/flashcards/CreateEditDeckModal';
import AIGenerateFlashcardsModal from './components/flashcards/AIGenerateFlashcardsModal';
import DeckViewModal from './components/flashcards/DeckViewModal';
import CreateEditFlashcardModal from './components/flashcards/CreateEditFlashcardModal';
import FlashcardReviewModal from './components/flashcards/FlashcardReviewModal';
import FileViewerModal from './components/FileViewerModal';
import GoogleAssistantGuideModal from './components/GoogleAssistantGuideModal';
import AIGuideModal from './components/AIGuideModal';
import CreateEditTaskModal from './components/CreateEditTaskModal';
import { MessagingModal } from './components/MessagingModal';
import UniversalSearch from './components/UniversalSearch';
import AnswerKeyUploadModal from './components/AnswerKeyUploadModal';
import SpecificMistakeAnalysisModal from './components/SpecificMistakeAnalysisModal';


declare global {
  interface Window {
    gapi: any;
    google: any;
  }
}

const API_URL = '/api';

// #region Modal State Definition
interface ModalState {
  id: string;
  componentId: string;
}

interface ModalControlProps {
  openModal: (modalId: string, setter: React.Dispatch<React.SetStateAction<boolean>> | ((val: any) => void), initialValue?: any) => void;
  closeModal: (modalId: string) => void;

  isExamTypeSelectionModalOpen: boolean; setIsExamTypeSelectionModalOpen: React.Dispatch<React.SetStateAction<boolean>>;
  isCreateModalOpen: boolean; setIsCreateModalOpen: React.Dispatch<React.SetStateAction<boolean>>;
  isAiParserModalOpen: boolean; setisAiParserModalOpen: React.Dispatch<React.SetStateAction<boolean>>;
  isPracticeModalOpen: boolean; setIsPracticeModalOpen: React.Dispatch<React.SetStateAction<boolean>>;
  isSettingsModalOpen: boolean; setIsSettingsModalOpen: React.Dispatch<React.SetStateAction<boolean>>;
  editingTask: ScheduleItem | null; setEditingTask: React.Dispatch<React.SetStateAction<ScheduleItem | null>>;
  viewingTask: ScheduleItem | null; setViewingTask: React.Dispatch<React.SetStateAction<ScheduleItem | null>>;
  practiceTask: HomeworkData | null; setPracticeTask: React.Dispatch<React.SetStateAction<HomeworkData | null>>;
  aiPracticeTest: { questions: PracticeQuestion[], answers: Record<string, string | string[]> } | null; setAiPracticeTest: React.Dispatch<React.SetStateAction<{ questions: PracticeQuestion[], answers: Record<string, string | string[]> } | null>>;
  isEditWeaknessesModalOpen: boolean; setIsEditWeaknessesModalOpen: React.Dispatch<React.SetStateAction<boolean>>;
  isLogResultModalOpen: boolean; setLogResultModalOpen: React.Dispatch<React.SetStateAction<boolean>>;
  initialScoreForModal: string | undefined; setInitialScoreForModal: React.Dispatch<React.SetStateAction<string | undefined>>;
  initialMistakesForModal: string | undefined; setInitialMistakesForModal: React.Dispatch<React.SetStateAction<string | undefined>>;
  isEditResultModalOpen: boolean; setEditResultModalOpen: React.Dispatch<React.SetStateAction<boolean>>;
  editingResult: ResultData | null; setEditingResult: React.Dispatch<React.SetStateAction<ResultData | null>>;
  isExamModalOpen: boolean; setIsExamModalOpen: React.Dispatch<React.SetStateAction<boolean>>;
  editingExam: ExamData | null; setEditingExam: React.Dispatch<React.SetStateAction<ExamData | null>>;
  isAiMistakeModalOpen: boolean; setAiMistakeModalOpen: React.Dispatch<React.SetStateAction<boolean>>;
  viewingReport: ResultData | null; setViewingReport: React.Dispatch<React.SetStateAction<ResultData | null>>;
  isAssistantGuideOpen: boolean; setAssistantGuideOpen: React.Dispatch<React.SetStateAction<boolean>>;
  isAiGuideModalOpen: boolean; setAiGuideModalOpen: React.Dispatch<React.SetStateAction<boolean>>;
  isSearchOpen: boolean; setIsSearchOpen: React.Dispatch<React.SetStateAction<boolean>>;
  searchInitialQuery: string | null; setSearchInitialQuery: React.Dispatch<React.SetStateAction<string | null>>;
  isSelectMode: boolean; setIsSelectMode: React.Dispatch<React.SetStateAction<boolean>>;
  selectedTaskIds: string[]; setSelectedTaskIds: React.Dispatch<React.SetStateAction<string[]>>;
  isMoveModalOpen: boolean; setMoveModalOpen: React.Dispatch<React.SetStateAction<boolean>>;
  isAiChatOpen: boolean; setAiChatOpen: React.Dispatch<React.SetStateAction<boolean>>;
  aiChatHistory: { role: string; parts: { text: string }[] }[]; setAiChatHistory: React.Dispatch<React.SetStateAction<{ role: string; parts: { text: string }[] }[]>>;
  showAiChatFab: boolean; setShowAiChatFab: React.Dispatch<React.SetStateAction<boolean>>;
  isAiChatLoading: boolean; setIsAiChatLoading: React.Dispatch<React.SetStateAction<boolean>>;
  isAiDoubtSolverOpen: boolean; setIsAiDoubtSolverOpen: React.Dispatch<React.SetStateAction<boolean>>;
  isCreateDeckModalOpen: boolean; setCreateDeckModalOpen: React.Dispatch<React.SetStateAction<boolean>>;
  isAiFlashcardModalOpen: boolean; setAiFlashcardModalOpen: React.Dispatch<React.SetStateAction<boolean>>;
  editingDeck: FlashcardDeck | null; setEditingDeck: React.Dispatch<React.SetStateAction<FlashcardDeck | null>>;
  viewingDeck: FlashcardDeck | null; setViewingDeck: React.Dispatch<React.SetStateAction<FlashcardDeck | null>>;
  isCreateCardModalOpen: boolean; setCreateCardModalOpen: React.Dispatch<React.SetStateAction<boolean>>;
  editingCard: Flashcard | null; setEditingCard: React.SetStateAction<Flashcard | null>;
  reviewingDeck: FlashcardDeck | null; setReviewingDeck: React.Dispatch<React.SetStateAction<FlashcardDeck | null>>;
  viewingFile: StudyMaterialItem | null; setViewingFile: React.Dispatch<React.SetStateAction<StudyMaterialItem | null>>;
  isMusicLibraryOpen: boolean; setIsMusicLibraryOpen: React.Dispatch<React.SetStateAction<boolean>>;
  analyzingMistake: number | null; setAnalyzingMistake: React.Dispatch<React.SetStateAction<number | null>>;
  handleMoveSelected: (taskIds: string[], newDate: string) => void;
  handleSaveDeck: (deck: FlashcardDeck) => void;
  handleDeleteCard: (deckId: string, cardId: string) => void;
  handleSaveCard: (deckId: string, card: Flashcard) => void;
  setDeepLinkAction: React.Dispatch<React.SetStateAction<any>>;
  isMessagingModalOpen: boolean; setMessagingModalOpen: React.Dispatch<React.SetStateAction<boolean>>;
  messagingStudent: StudentData | null; setMessagingStudent: React.Dispatch<React.SetStateAction<StudentData | null>>;
  isAnswerKeyUploadModalOpen: boolean; setAnswerKeyUploadModalOpen: React.Dispatch<React.SetStateAction<boolean>>;
  isProfileModalOpen: boolean; setIsProfileModalOpen: React.Dispatch<React.SetStateAction<boolean>>;
  isSpecificMistakeAnalysisModalOpen: boolean; setIsSpecificMistakeAnalysisModalOpen: React.Dispatch<React.SetStateAction<boolean>>;
}
// #endregion Modal State Definition


const App: React.FC = () => {
  const { currentUser, userRole, isLoading, isDemoMode, enterDemoMode, logout, refreshUser, token, googleAuthStatus, setGoogleAuthStatus, loginWithToken, verificationEmail, setVerificationEmail } = useAuth();
  const { isFullScreenPlayerOpen, toggleLibrary, isLibraryOpen, currentTrack } = useMusicPlayer(); 
    
  const [allStudents, setAllStudents] = useState<StudentData[]>([]);
  const [allDoubts, setAllDoubts] = useState<DoubtData[]>([]);
  const [backendStatus, setBackendStatus] = useState<'checking' | 'online' | 'offline' | 'misconfigured'>('checking');
  const [googleClientId, setGoogleClientId] = useState<string | null>(null);
  const [apiTokenLoaded, setApiTokenLoaded] = useState<string | null>(null);

  // Modal States
  const [isExamTypeSelectionModalOpen, setIsExamTypeSelectionModalOpen] = useState(false);
  const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);
  const [isAiParserModalOpen, setisAiParserModalOpen] = useState(false);
  const [isPracticeModalOpen, setIsPracticeModalOpen] = useState(false);
  const [isSettingsModalOpen, setIsSettingsModalOpen] = useState(false);
  const [editingTask, setEditingTask] = useState<ScheduleItem | null>(null);
  const [viewingTask, setViewingTask] = useState<ScheduleItem | null>(null);
  const [practiceTask, setPracticeTask] = useState<HomeworkData | null>(null);
  const [aiPracticeTest, setAiPracticeTest] = useState<{ questions: PracticeQuestion[], answers: Record<string, string | string[]> } | null>(null);
  const [isEditWeaknessesModalOpen, setIsEditWeaknessesModalOpen] = useState(false);
  const [isLogResultModalOpen, setLogResultModalOpen] = useState(false);
  const [initialScoreForModal, setInitialScoreForModal] = useState<string | undefined>();
  const [initialMistakesForModal, setInitialMistakesForModal] = useState<string | undefined>();
  const [isEditResultModalOpen, setEditResultModalOpen] = useState(false);
  const [editingResult, setEditingResult] = useState<ResultData | null>(null);
  const [isExamModalOpen, setIsExamModalOpen] = useState(false);
  const [editingExam, setEditingExam] = useState<ExamData | null>(null);
  const [isAiMistakeModalOpen, setAiMistakeModalOpen] = useState(false);
  const [viewingReport, setViewingReport] = useState<ResultData | null>(null);
  const [isAssistantGuideOpen, setAssistantGuideOpen] = useState(false);
  const [isAiGuideModalOpen, setAiGuideModalOpen] = useState(false);
  const [isSearchOpen, setIsSearchOpen] = useState(false);
  const [searchInitialQuery, setSearchInitialQuery] = useState<string | null>(null);
  const [isSelectMode, setIsSelectMode] = useState(false);
  const [selectedTaskIds, setSelectedTaskIds] = useState<string[]>([]);
  const [isMoveModalOpen, setMoveModalOpen] = useState(false);
  const [isAiChatOpen, setAiChatOpen] = useState(false);
  const [aiChatHistory, setAiChatHistory] = useState<{ role: string; parts: { text: string }[] }[]>([]);
  const [showAiChatFab, setShowAiChatFab] = useState(false);
  const [isAiChatLoading, setIsAiChatLoading] = useState(false);
  const [isCreateDeckModalOpen, setCreateDeckModalOpen] = useState(false);
  const [isAiFlashcardModalOpen, setAiFlashcardModalOpen] = useState(false);
  const [editingDeck, setEditingDeck] = useState<FlashcardDeck | null>(null);
  const [viewingDeck, setViewingDeck] = useState<FlashcardDeck | null>(null);
  const [isCreateCardModalOpen, setCreateCardModalOpen] = useState(false);
  const [editingCard, setEditingCard] = useState<Flashcard | null>(null);
  const [reviewingDeck, setReviewingDeck] = useState<FlashcardDeck | null>(null);
  const [viewingFile, setViewingFile] = useState<StudyMaterialItem | null>(null);
  const [isMusicLibraryOpen, setIsMusicLibraryOpen] = useState(false);
  const [analyzingMistake, setAnalyzingMistake] = useState<number | null>(null);
  const [deepLinkAction, setDeepLinkAction] = useState<any | null>(null);
  const [isMessagingModalOpen, setMessagingModalOpen] = useState(false);
  const [messagingStudent, setMessagingStudent] = useState<StudentData | null>(null);
  const [isAnswerKeyUploadModalOpen, setAnswerKeyUploadModalOpen] = useState(false);
  const [isProfileModalOpen, setIsProfileModalOpen] = useState(false);
  const [isSpecificMistakeAnalysisModalOpen, setIsSpecificMistakeAnalysisModalOpen] = useState(false);
  const [isAiDoubtSolverOpen, setIsAiDoubtSolverOpen] = useState(false);


  // General App State
  const [isSyncing, setIsSyncing] = useState(false);
  const [gapiLoaded, setGapiLoaded] = useState(false);
  const [resetToken, setResetToken] = useState<string | null>(null);

  // Modal History Management
  const modalStackRef = useRef<ModalState[]>([]);
  const currentModalIdRef = useRef<string | null>(null);
  const modalSettersRef = useRef<Map<string, React.Dispatch<React.SetStateAction<boolean>> | ((val: any) => void)>>(new Map());

  useEffect(() => {
    modalSettersRef.current.set('ExamTypeSelectionModal', setIsExamTypeSelectionModalOpen);
    modalSettersRef.current.set('CreateEditTaskModal', setIsCreateModalOpen);
    modalSettersRef.current.set('AIParserModal', setisAiParserModalOpen);
    modalSettersRef.current.set('CustomPracticeModal', setIsPracticeModalOpen);
    modalSettersRef.current.set('SettingsModal', setIsSettingsModalOpen);
    modalSettersRef.current.set('EditWeaknessesModal', setIsEditWeaknessesModalOpen);
    modalSettersRef.current.set('LogResultModal', setLogResultModalOpen);
    modalSettersRef.current.set('EditResultModal', setEditResultModalOpen);
    modalSettersRef.current.set('CreateEditExamModal', setIsExamModalOpen);
    modalSettersRef.current.set('AIMistakeAnalysisModal', setAiMistakeModalOpen);
    modalSettersRef.current.set('AIDoubtSolverModal', setIsAiDoubtSolverOpen);
    modalSettersRef.current.set('AIChatPopup', setAiChatOpen);
    modalSettersRef.current.set('TestReportModal', setViewingReport);
    modalSettersRef.current.set('MoveTasksModal', setMoveModalOpen);
    modalSettersRef.current.set('MusicLibraryModal', setIsMusicLibraryOpen);
    modalSettersRef.current.set('DeepLinkConfirmationModal', setDeepLinkAction);
    modalSettersRef.current.set('CreateEditDeckModal', setCreateDeckModalOpen);
    modalSettersRef.current.set('AIGenerateFlashcardsModal', setAiFlashcardModalOpen);
    modalSettersRef.current.set('DeckViewModal', setViewingDeck);
    modalSettersRef.current.set('CreateEditFlashcardModal', setCreateCardModalOpen);
    modalSettersRef.current.set('FlashcardReviewModal', setReviewingDeck);
    modalSettersRef.current.set('FileViewerModal', setViewingFile);
    modalSettersRef.current.set('GoogleAssistantGuideModal', setAssistantGuideOpen);
    modalSettersRef.current.set('AIGuideModal', setAiGuideModalOpen);
    modalSettersRef.current.set('MessagingModal', setMessagingModalOpen);
    modalSettersRef.current.set('AnswerKeyUploadModal', setAnswerKeyUploadModalOpen);
    modalSettersRef.current.set('ProfileModal', setIsProfileModalOpen);
    modalSettersRef.current.set('SpecificMistakeAnalysisModal', setIsSpecificMistakeAnalysisModalOpen);
    modalSettersRef.current.set('UniversalSearch', setIsSearchOpen);
  }, [
    setIsExamTypeSelectionModalOpen, setIsCreateModalOpen, setisAiParserModalOpen, setIsPracticeModalOpen,
    setIsSettingsModalOpen, setIsEditWeaknessesModalOpen, setLogResultModalOpen, setEditResultModalOpen, 
    setIsExamModalOpen, setAiMistakeModalOpen, setViewingReport, setAssistantGuideOpen, setAiGuideModalOpen, 
    setIsSearchOpen, setMoveModalOpen, setAiChatOpen, setIsAiDoubtSolverOpen, setCreateDeckModalOpen, 
    setAiFlashcardModalOpen, setEditingDeck, setViewingDeck, setCreateCardModalOpen, setEditingCard, 
    setReviewingDeck, setViewingFile, setIsMusicLibraryOpen, setDeepLinkAction, setMessagingModalOpen, 
    setAnswerKeyUploadModalOpen, setIsProfileModalOpen, setIsSpecificMistakeAnalysisModalOpen,
  ]);

  const openModal = useCallback((modalId: string, setter: React.Dispatch<React.SetStateAction<boolean>> | ((val: any) => void), initialValue?: any) => {
    const isBooleanSetter = typeof initialValue === 'undefined' || typeof initialValue === 'boolean';

    if (isBooleanSetter) {
      (setter as React.Dispatch<React.SetStateAction<boolean>>)(true);
    } else {
      (setter as (val: any) => void)(initialValue);
    }
      
    const newModalState: ModalState = { id: modalId, componentId: `${modalId}-${Date.now()}` };
    modalStackRef.current.push(newModalState);
    currentModalIdRef.current = modalId; 
    
    window.history.pushState({ modal: newModalState.componentId }, '');
  }, []);

  const closeModal = useCallback((modalId: string) => {
    const setter = modalSettersRef.current.get(modalId);
    if (setter) {
      const isBooleanSetter = String(setter).includes('setIs');
      if (isBooleanSetter) {
        (setter as React.Dispatch<React.SetStateAction<boolean>>)(false);
      } else {
        (setter as (val: any) => void)(null);
      }
    }

    modalStackRef.current = modalStackRef.current.filter(m => m.id !== modalId);
    currentModalIdRef.current = modalStackRef.current.length > 0 ? modalStackRef.current[modalStackRef.current.length - 1].id : null;
  }, []);


  useEffect(() => {
    const handlePopState = (event: PopStateEvent) => {
      const isModalHistoryState = event.state && event.state.modal;

      if (isModalHistoryState) {
        const modalToClose = modalStackRef.current[modalStackRef.current.length - 1];
        
        if (modalToClose && modalToClose.componentId === event.state.modal) {
          const setter = modalSettersRef.current.get(modalToClose.id);
          if (setter) {
            const isBooleanSetter = String(setter).includes('setIs');
            if (isBooleanSetter) (setter as React.Dispatch<React.SetStateAction<boolean>>)(false); else (setter as (val: any) => void)(null);
          }
          modalStackRef.current.pop();
          currentModalIdRef.current = modalStackRef.current.length > 0 ? modalStackRef.current[modalStackRef.current.length - 1].id : null;
        } else if (modalStackRef.current.length > 0) {
          const topModal = modalStackRef.current[modalStackRef.current.length - 1];
          const setter = modalSettersRef.current.get(topModal.id);
          if (setter) {
            const isBooleanSetter = String(setter).includes('setIs');
            if (isBooleanSetter) (setter as React.Dispatch<React.SetStateAction<boolean>>)(false); else (setter as (val: any) => void)(null);
          }
          modalStackRef.current = [];
          currentModalIdRef.current = null;
        }
      } else {
        if (modalStackRef.current.length > 0) {
          modalStackRef.current.forEach(m => {
            const setter = modalSettersRef.current.get(m.id);
            if (setter) {
              const isBooleanSetter = String(setter).includes('setIs');
              if (isBooleanSetter) (setter as React.Dispatch<React.SetStateAction<boolean>>)(false); else (setter as (val: any) => void)(null);
            }
          });
          modalStackRef.current = [];
          currentModalIdRef.current = null;
        }
      }
    };

    window.addEventListener('popstate', handlePopState);
    return () => window.removeEventListener('popstate', handlePopState);
  }, [closeModal]);


  const checkBackendStatus = useCallback(async () => {
    try {
      const res = await api.getPublicConfig();
      if (res.status === 'misconfigured') {
          setBackendStatus('misconfigured');
      } else {
          setBackendStatus('online');
          setGoogleClientId(res.googleClientId);
      }
    } catch (error: any) {
      console.error("Backend status check failed:", error);
      if (error.status === 'misconfigured') {
          setBackendStatus('misconfigured');
      } else {
          setBackendStatus('offline');
      }
    }
  }, []);

  // Initial check and periodic heartbeat
  useEffect(() => {
    checkBackendStatus();

    const interval = setInterval(async () => {
      if (token) {
        try {
          await api.heartbeat();
        } catch (error) {
          console.warn('Heartbeat failed, backend may be offline:', error);
          checkBackendStatus();
        }
      } else {
        checkBackendStatus();
      }
    }, 30000);

    return () => clearInterval(interval);
  }, [token, checkBackendStatus]);

  // Google API client initialization
  useEffect(() => {
    if (!googleClientId || backendStatus !== 'online') return;
    if (!window.gapi || !window.google) {
      console.warn("Google API scripts not yet loaded.");
      return;
    }

    const initGoogleClient = async () => {
      try {
        auth.initClient(
          googleClientId,
          (isSignedIn: boolean) => setGoogleAuthStatus(isSignedIn ? 'signed_in' : 'signed_out'),
          (error: any) => console.error("Google Auth Init Error", error)
        );
        setGapiLoaded(true);
      } catch (error) {
        console.error("Failed to initialize Google GAPI client:", error);
      }
    };

    if (window.gapi.client && window.gapi.client.init) {
      initGoogleClient();
    } else {
      window.gapi.load('client', initGoogleClient);
    }
  }, [googleClientId, backendStatus, setGoogleAuthStatus]);

  // Deep Link Handling
  useEffect(() => {
    const params = new URLSearchParams(window.location.search);
    const action = params.get('action');
    const dataStr = params.get('data');
    const resetToken = params.get('reset-token');

    if (resetToken) {
      setResetToken(resetToken);
      const newUrl = new URL(window.location.href);
      newUrl.searchParams.delete('reset-token');
      window.history.replaceState({}, document.title, newUrl.toString());
      return;
    }

    if (action && dataStr) {
      try {
        const data = JSON.parse(decodeURIComponent(dataStr));
        setDeepLinkAction({ action, data });
        const newUrl = new URL(window.location.href);
        newUrl.searchParams.delete('action');
        newUrl.searchParams.delete('data');
        window.history.replaceState({}, document.title, newUrl.toString());
      } catch (error) {
        console.error("Failed to parse deep link data:", error);
      }
    }
  }, []);

  // Handle deep link actions
  useEffect(() => {
    if (!deepLinkAction || !currentUser) return;

    const handleDeepLink = async () => {
      const { action, data } = deepLinkAction;
      setDeepLinkAction(null);

      if (action === 'new_schedule' || action === 'import_data' || action === 'import_exam') {
        openModal('DeepLinkConfirmationModal', setDeepLinkAction, deepLinkAction.data);
      } else if (action === 'start_practice' && data?.id) {
        const homework = currentUser.SCHEDULE_ITEMS.find(item => item.ID === data.id && item.type === 'HOMEWORK') as HomeworkData;
        if (homework) {
          setPracticeTask(homework);
          openModal('CustomPracticeModal', setIsPracticeModalOpen);
        } else {
          alert("Homework task not found for deep link.");
        }
      } else if (action === 'view_task' && data?.id) {
          const task = currentUser.SCHEDULE_ITEMS.find(item => item.ID === data.id);
          if(task) {
              setViewingTask(task);
              openModal('CreateEditTaskModal', setIsCreateModalOpen);
          } else {
              alert("Task not found for deep link.");
          }
      } else if (action === 'search' && data?.query) {
        setSearchInitialQuery(data.query);
        openModal('UniversalSearch', setIsSearchOpen);
      }
    };

    handleDeepLink();
  }, [deepLinkAction, currentUser, openModal, setDeepLinkAction, setPracticeTask, setIsPracticeModalOpen, setViewingTask, setIsCreateModalOpen, setSearchInitialQuery, setIsSearchOpen]);


  // Handlers for specific student data actions
  const handleSaveTask = useCallback(async (task: ScheduleItem) => {
    if (!currentUser) return;
    setIsSyncing(true);
    try {
      await api.saveTask(task);
      await refreshUser();
      if (currentUser.CONFIG.isCalendarSyncEnabled && googleAuthStatus === 'signed_in') {
        if ('googleEventId' in task && task.googleEventId) {
          await gcal.updateEvent(task.googleEventId, task);
        } else {
          const eventId = await gcal.createEvent(task);
          const updatedTask = { ...task, googleEventId: eventId };
          await api.saveTask(updatedTask); 
          await refreshUser();
        }
      }
    } catch (error) {
      console.error("Failed to save task:", error);
      alert("Failed to save task. Please try again or check backend connection.");
    } finally {
      setIsSyncing(false);
    }
  }, [currentUser, refreshUser, googleAuthStatus]);

  const handleSaveBatchTasks = useCallback(async (tasks: ScheduleItem[]) => {
    if (!currentUser) return;
    setIsSyncing(true);
    try {
      await api.saveBatchTasks(tasks);
      await refreshUser();
    } catch (error) {
      console.error("Failed to save batch tasks:", error);
      alert("Failed to save batch tasks. Please try again or check backend connection.");
    } finally {
      setIsSyncing(false);
    }
  }, [currentUser, refreshUser]);
  
  // FIX: handleClearAllSchedule
  const handleClearAllSchedule = useCallback(async () => {
    if (!currentUser) return;
    if (!window.confirm("Are you sure you want to clear all your schedule items? This cannot be undone.")) return;
    setIsSyncing(true);
    try {
        await api.clearAllSchedule();
        await refreshUser();
        alert("All schedule items cleared.");
    } catch (error: any) {
        console.error("Failed to clear schedule:", error);
        alert(`Failed to clear schedule: ${error.message}`);
    } finally {
        setIsSyncing(false);
    }
  }, [currentUser, refreshUser]);

  const handleDeleteTask = useCallback(async (taskId: string) => {
    if (!currentUser) return;
    if (!window.confirm("Are you sure you want to delete this task?")) return;
    setIsSyncing(true);
    try {
      const taskToDelete = currentUser.SCHEDULE_ITEMS.find(item => item.ID === taskId);
      if (taskToDelete && 'googleEventId' in taskToDelete && taskToDelete.googleEventId && googleAuthStatus === 'signed_in') {
        await gcal.deleteEvent(taskToDelete.googleEventId);
      }
      await api.deleteTask(taskId);
      await refreshUser();
    } catch (error) {
      console.error("Failed to delete task:", error);
      alert("Failed to delete task. Please try again or check backend connection.");
    } finally {
      setIsSyncing(false);
    }
  }, [currentUser, refreshUser, googleAuthStatus]);

  const handleToggleMistakeFixed = useCallback(async (resultId: string, mistake: string) => {
    if (!currentUser) return;
    setIsSyncing(true);
    try {
      const result = currentUser.RESULTS.find(r => r.ID === resultId);
      if (!result) throw new Error("Result not found");

      const isFixed = result.FIXED_MISTAKES?.includes(mistake);
      const updatedFixedMistakes = isFixed
          ? result.FIXED_MISTAKES.filter(m => m !== mistake)
          : [...(result.FIXED_MISTAKES || []), mistake];
      
      const updatedResult = { ...result, FIXED_MISTAKES: updatedFixedMistakes };
      await api.updateResult(updatedResult);
      await refreshUser();
    } catch (error) {
      console.error("Failed to update mistake status:", error);
      alert("Failed to update mistake status. Please try again.");
    } finally {
      setIsSyncing(false);
    }
  }, [currentUser, refreshUser]);

  const handleUpdateConfig = useCallback(async (config: Partial<Config>) => {
    if (!currentUser) return;
    setIsSyncing(true);
    try {
      await api.updateConfig(config);
      await refreshUser();
      alert("Settings saved!");
    } catch (error) {
      console.error("Failed to update config:", error);
      alert("Failed to save settings. Please try again or check backend connection.");
    } finally {
      setIsSyncing(false);
    }
  }, [currentUser, refreshUser]);

  const handleLogStudySession = useCallback(async (session: Omit<StudySession, 'date'> & { date: string }) => {
    if (!currentUser) return;
    setIsSyncing(true);
    try {
        await api.saveStudySession(session);
        await refreshUser();
    } catch (error) {
        console.error("Failed to log study session:", error);
        alert("Failed to log study session. Please try again.");
    } finally {
        setIsSyncing(false);
    }
  }, [currentUser, refreshUser]);

  const handleUpdateWeaknesses = useCallback(async (weaknesses: string[]) => {
    if (!currentUser) return;
    setIsSyncing(true);
    try {
        await api.updateConfig({ WEAK: weaknesses });
        await refreshUser();
    } catch (error) {
        console.error("Failed to update weaknesses:", error);
        alert("Failed to update weaknesses. Please try again.");
    } finally {
        setIsSyncing(false);
    }
  }, [currentUser, refreshUser]);

  const handleLogResult = useCallback(async (result: ResultData) => {
    if (!currentUser) return;
    setIsSyncing(true);
    try {
        await api.updateResult(result);
        await refreshUser();
        alert("Test result logged successfully!");
    } catch (error) {
        console.error("Failed to log result:", error);
        alert("Failed to log test result. Please try again.");
    } finally {
        setIsSyncing(false);
    }
  }, [currentUser, refreshUser]);

  const handleAddExam = useCallback(async (exam: ExamData) => {
    if (!currentUser) return;
    setIsSyncing(true);
    try {
        await api.addExam(exam);
        await refreshUser();
        alert("Exam added successfully!");
    } catch (error) {
        console.error("Failed to add exam:", error);
        alert("Failed to add exam. Please try again.");
    } finally {
        setIsSyncing(false);
    }
  }, [currentUser, refreshUser]);

  const handleUpdateExam = useCallback(async (exam: ExamData) => {
    if (!currentUser) return;
    setIsSyncing(true);
    try {
        await api.updateExam(exam);
        await refreshUser();
        alert("Exam updated successfully!");
    } catch (error) {
        console.error("Failed to update exam:", error);
        alert("Failed to update exam. Please try again.");
    } finally {
        setIsSyncing(false);
    }
  }, [currentUser, refreshUser]);

  const handleDeleteExam = useCallback(async (examId: string) => {
    if (!currentUser) return;
    if (!window.confirm("Are you sure you want to delete this exam?")) return;
    setIsSyncing(true);
    try {
        await api.deleteExam(examId);
        await refreshUser();
        alert("Exam deleted successfully.");
    } catch (error) {
        console.error("Failed to delete exam:", error);
        alert("Failed to delete exam. Please try again.");
    } finally {
        setIsSyncing(false);
    }
  }, [currentUser, refreshUser]);

  const handleExportToIcs = useCallback(() => {
    if (!currentUser) return;
    exportCalendar(currentUser.SCHEDULE_ITEMS, currentUser.EXAMS, currentUser.fullName);
  }, [currentUser]);

  const handleBatchImport = useCallback(async (data: { schedules: ScheduleItem[]; exams: ExamData[]; results: ResultData[]; weaknesses: string[]; }) => {
    if (!currentUser) return;
    setIsSyncing(true);
    try {
        if (data.schedules.length > 0) await api.saveBatchTasks(data.schedules);
        if (data.exams.length > 0) {
            for(const exam of data.exams) {
                await api.addExam(exam);
            }
        }
        if (data.results.length > 0) {
             for(const result of data.results) {
                await api.updateResult(result);
            }
        }
        if (data.weaknesses.length > 0) {
            const newWeaknesses = [...new Set([...currentUser.CONFIG.WEAK, ...data.weaknesses])];
            await api.updateConfig({ WEAK: newWeaknesses });
        }
        await refreshUser();
        alert("Data imported successfully!");
    } catch (error) {
        console.error("Failed to batch import data:", error);
        alert("Failed to import data. Please try again.");
    } finally {
        setIsSyncing(false);
    }
  }, [currentUser, refreshUser]);

  const handleGoogleSignIn = useCallback(async () => {
    if (!gapiLoaded) {
      alert("Google API not fully loaded. Please try again in a moment.");
      return;
    }
    auth.handleSignIn();
  }, [gapiLoaded]);

  const handleGoogleSignOut = useCallback(() => {
    if (googleAuthStatus !== 'signed_in') return;
    auth.handleSignOut((isSignedIn: boolean) => {
      setGoogleAuthStatus(isSignedIn ? 'signed_in' : 'signed_out');
      alert("Disconnected from Google services.");
    });
  }, [googleAuthStatus, setGoogleAuthStatus]);

  const handleFullCalendarSync = useCallback(async () => {
    if (!currentUser || googleAuthStatus !== 'signed_in') return;
    setIsSyncing(true);
    try {
        const events = await gcal.listEvents();
        alert(`Fetched ${events.length} events from Google Calendar.`);
    } catch (error) {
        console.error("Full calendar sync failed:", error);
        alert("Failed to sync calendar. Ensure permissions are granted and try again.");
    } finally {
        setIsSyncing(false);
    }
  }, [currentUser, googleAuthStatus]);

  const handleBackupToDrive = useCallback(async () => {
    if (!currentUser || googleAuthStatus !== 'signed_in') return;
    setIsSyncing(true);
    try {
        const fullUserData = await api.getMe();
        const dataToSave = JSON.stringify(fullUserData);
        const fileId = await gdrive.uploadData(dataToSave, currentUser.CONFIG.googleDriveFileId);
        await api.updateConfig({ googleDriveFileId: fileId, driveLastSync: new Date().toISOString() });
        await refreshUser();
        alert("Data backed up to Google Drive!");
    } catch (error) {
        console.error("Drive backup failed:", error);
        alert("Failed to backup to Drive. Ensure permissions are granted and try again.");
    } finally {
        setIsSyncing(false);
    }
  }, [currentUser, googleAuthStatus, refreshUser]);

  const handleRestoreFromDrive = useCallback(async () => {
    if (!currentUser || googleAuthStatus !== 'signed_in' || !currentUser.CONFIG.googleDriveFileId) return;
    if (!window.confirm("Are you sure you want to restore data from Google Drive? This will overwrite your current app data.")) return;
    setIsSyncing(true);
    try {
        const data = await gdrive.downloadData(currentUser.CONFIG.googleDriveFileId);
        const restoredUserData = JSON.parse(data);
        await api.fullSync(restoredUserData);
        await refreshUser();
        alert("Data restored from Google Drive!");
    } catch (error) {
        console.error("Drive restore failed:", error);
        alert("Failed to restore from Drive. The backup file might be missing or an error occurred.");
    } finally {
        setIsSyncing(false);
    }
  }, [currentUser, googleAuthStatus, refreshUser]);

  // Handler for posting doubts to community
  const handlePostDoubt = useCallback(async (question: string, image?: string) => {
    if (!currentUser) return;
    try {
      await api.postDoubt(question, image);
      await refreshUser();
    } catch (error) {
      alert("Failed to post doubt.");
    }
  }, [currentUser, refreshUser]);

  // Handler for posting solutions to doubts
  const handlePostSolution = useCallback(async (doubtId: string, solution: string, image?: string) => {
    if (!currentUser) return;
    try {
      await api.postSolution(doubtId, solution, image);
      await refreshUser();
    } catch (error) {
      alert("Failed to post solution.");
    }
  }, [currentUser, refreshUser]);

  // Handler for moving selected tasks to a new date
  const handleMoveSelectedTasks = useCallback(async (taskIds: string[], newDate: string) => {
    if (!currentUser) return;
    setIsSyncing(true);
    try {
        await api.batchMoveTasks(taskIds, newDate);
        await refreshUser();
        alert(`Moved ${taskIds.length} tasks to ${newDate}.`);
    } catch (error) {
        console.error("Failed to move tasks:", error);
        alert("Failed to move tasks. Please try again.");
    } finally {
        setIsSyncing(false);
    }
  }, [currentUser, refreshUser]);
  
  // Handlers for Flashcard Decks (passed to StudentDashboard)
  const handleSaveDeck = useCallback(async (deck: FlashcardDeck) => {
    if (!currentUser) return;
    setIsSyncing(true);
    try {
        const currentDecks = currentUser.CONFIG.flashcardDecks || [];
        const existingIndex = currentDecks.findIndex(d => d.id === deck.id);
        let newDecks;
        if (existingIndex >= 0) {
            newDecks = [...currentDecks];
            newDecks[existingIndex] = deck;
        } else {
            newDecks = [...currentDecks, deck];
        }
        await api.updateConfig({ flashcardDecks: newDecks });
        await refreshUser();
    } catch (error) {
        console.error("Failed to save deck:", error);
        alert("Failed to save flashcard deck.");
    } finally {
        setIsSyncing(false);
    }
  }, [currentUser, refreshUser]);

  const handleDeleteDeck = useCallback(async (deckId: string) => {
    if (!currentUser) return;
    if (!window.confirm("Are you sure you want to delete this deck and all its cards?")) return;
    setIsSyncing(true);
    try {
        const newDecks = currentUser.CONFIG.flashcardDecks?.filter(d => d.id !== deckId) || [];
        await api.updateConfig({ flashcardDecks: newDecks });
        await refreshUser();
        alert("Deck deleted.");
    } catch (error) {
        console.error("Failed to delete deck:", error);
        alert("Failed to delete flashcard deck.");
    } finally {
        setIsSyncing(false);
    }
  }, [currentUser, refreshUser]);

  const handleSaveCard = useCallback(async (deckId: string, card: Flashcard) => {
    if (!currentUser) return;
    setIsSyncing(true);
    try {
        const currentDecks = currentUser.CONFIG.flashcardDecks || [];
        const targetDeckIndex = currentDecks.findIndex(d => d.id === deckId);
        if (targetDeckIndex === -1) throw new Error("Deck not found");

        const newDecks = [...currentDecks];
        const targetDeck = { ...newDecks[targetDeckIndex] };
        
        const existingCardIndex = targetDeck.cards.findIndex(c => c.id === card.id);
        if (existingCardIndex >= 0) {
            targetDeck.cards[existingCardIndex] = card;
        } else {
            targetDeck.cards.push(card);
        }
        newDecks[targetDeckIndex] = targetDeck;
        
        await api.updateConfig({ flashcardDecks: newDecks });
        await refreshUser();
    } catch (error) {
        console.error("Failed to save card:", error);
        alert("Failed to save flashcard.");
    } finally {
        setIsSyncing(false);
    }
  }, [currentUser, refreshUser]);

  const handleDeleteCard = useCallback(async (deckId: string, cardId: string) => {
    if (!currentUser) return;
    if (!window.confirm("Are you sure you want to delete this card?")) return;
    setIsSyncing(true);
    try {
        const currentDecks = currentUser.CONFIG.flashcardDecks || [];
        const newDecks = currentDecks.map(deck => 
            deck.id === deckId ? { ...deck, cards: deck.cards.filter(c => c.id !== cardId) } : deck
        );
        await api.updateConfig({ flashcardDecks: newDecks });
        await refreshUser();
    } catch (error) {
        console.error("Failed to delete card:", error);
        alert("Failed to delete flashcard.");
    } finally {
        setIsSyncing(false);
    }
  }, [currentUser, refreshUser]);

  // For Admin broadcasting tasks
  const handleBroadcastTask = useCallback(async (task: ScheduleItem, examType: 'ALL' | 'JEE' | 'NEET') => {
    if (!currentUser || userRole !== 'admin') return;
    setIsSyncing(true);
    try {
        await api.broadcastTask(task, examType);
        alert("Task broadcasted successfully!");
    } catch (error) {
        console.error("Failed to broadcast task:", error);
        alert("Failed to broadcast task. Please try again.");
    } finally {
        setIsSyncing(false);
    }
  }, [currentUser, userRole]);

  // For Admin to clear all schedule data for a student
  const handleClearStudentData = useCallback(async (sid: string) => {
    if (userRole !== 'admin') return;
    setIsSyncing(true);
    try {
      await api.clearStudentData(sid);
      alert(`All data for student ${sid} cleared.`);
      await refreshUser();
    } catch (error) {
      console.error("Failed to clear student data:", error);
      alert("Failed to clear student data.");
    } finally {
      setIsSyncing(false);
    }
  }, [userRole, refreshUser]);
  
  // For Admin to delete a student account
  const handleDeleteStudent = useCallback(async (sid: string) => {
    if (userRole !== 'admin') return;
    if (!window.confirm(`Are you sure you want to delete student ${sid}? This is irreversible.`)) return;
    setIsSyncing(true);
    try {
      await api.deleteStudent(sid);
      alert(`Student ${sid} deleted.`);
      await refreshUser();
    } catch (error) {
      console.error("Failed to delete student:", error);
      alert("Failed to delete student.");
    } finally {
      setIsSyncing(false);
    }
  }, [userRole, refreshUser]);

  // For Admin to toggle Unacademy subscription (placeholder)
  const handleToggleUnacademySub = useCallback(async (sid: string) => {
      alert(`Toggle Unacademy sub for ${sid} - not yet fully implemented.`);
  }, []);

  // For Admin to impersonate a student
  const handleImpersonateStudent = useCallback(async (sid: string) => {
    if (userRole !== 'admin') return;
    try {
      const { token } = await api.impersonateStudent(sid);
      loginWithToken(token);
    } catch (error) {
      console.error("Impersonation failed:", error);
      alert("Failed to impersonate student.");
    }
  }, [userRole, loginWithToken]);

  // Group all modal control props for easier passing
  const modalControlProps: ModalControlProps = useMemo(() => ({
    openModal, closeModal,
    isExamTypeSelectionModalOpen, setIsExamTypeSelectionModalOpen,
    isCreateModalOpen, setIsCreateModalOpen,
    isAiParserModalOpen, setisAiParserModalOpen,
    isPracticeModalOpen, setIsPracticeModalOpen,
    isSettingsModalOpen, setIsSettingsModalOpen,
    editingTask, setEditingTask,
    viewingTask, setViewingTask,
    practiceTask, setPracticeTask,
    aiPracticeTest, setAiPracticeTest,
    isEditWeaknessesModalOpen, setIsEditWeaknessesModalOpen,
    isLogResultModalOpen, setLogResultModalOpen,
    initialScoreForModal, setInitialScoreForModal,
    initialMistakesForModal, setInitialMistakesForModal,
    isEditResultModalOpen, setEditResultModalOpen,
    editingResult, setEditingResult,
    isExamModalOpen, setIsExamModalOpen,
    editingExam, setEditingExam,
    isAiMistakeModalOpen, setAiMistakeModalOpen,
    viewingReport, setViewingReport,
    isAssistantGuideOpen, setAssistantGuideOpen,
    isAiGuideModalOpen, setAiGuideModalOpen,
    isSearchOpen, setIsSearchOpen,
    searchInitialQuery, setSearchInitialQuery,
    isSelectMode, setIsSelectMode,
    selectedTaskIds, setSelectedTaskIds,
    isMoveModalOpen, setMoveModalOpen,
    isAiChatOpen, setAiChatOpen,
    aiChatHistory, setAiChatHistory,
    showAiChatFab, setShowAiChatFab,
    isAiChatLoading, setIsAiChatLoading,
    isAiDoubtSolverOpen, setIsAiDoubtSolverOpen, 
    isCreateDeckModalOpen, setCreateDeckModalOpen,
    isAiFlashcardModalOpen, setAiFlashcardModalOpen,
    editingDeck, setEditingDeck,
    viewingDeck, setViewingDeck,
    isCreateCardModalOpen, setCreateCardModalOpen, 
    editingCard, setEditingCard,
    reviewingDeck, setReviewingDeck,
    viewingFile, setViewingFile,
    isMusicLibraryOpen, setIsMusicLibraryOpen,
    analyzingMistake, setAnalyzingMistake,
    handleMoveSelected: handleMoveSelectedTasks,
    handleSaveDeck, 
    handleDeleteCard, 
    handleSaveCard,
    setDeepLinkAction,
    isMessagingModalOpen, setMessagingModalOpen,
    messagingStudent, setMessagingStudent,
    isAnswerKeyUploadModalOpen, setAnswerKeyUploadModalOpen,
    isProfileModalOpen, setIsProfileModalOpen,
    isSpecificMistakeAnalysisModalOpen, setIsSpecificMistakeAnalysisModalOpen
  ]), [
    openModal, closeModal, isExamTypeSelectionModalOpen, setIsExamTypeSelectionModalOpen,
    isCreateModalOpen, setIsCreateModalOpen, setisAiParserModalOpen, setIsPracticeModalOpen,
    isSettingsModalOpen, setIsSettingsModalOpen, editingTask, setEditingTask,
    viewingTask, setViewingTask, practiceTask, setPracticeTask, aiPracticeTest, setAiPracticeTest,
    isEditWeaknessesModalOpen, setIsEditWeaknessesModalOpen, isLogResultModalOpen, setLogResultModalOpen,
    initialScoreForModal, setInitialScoreForModal, initialMistakesForModal, setInitialMistakesForModal,
    isEditResultModalOpen, setEditResultModalOpen, editingResult, setEditingResult,
    isExamModalOpen, setIsExamModalOpen, editingExam, setEditingExam,
    isAiMistakeModalOpen, setAiMistakeModalOpen, viewingReport, setViewingReport,
    isAssistantGuideOpen, setAssistantGuideOpen, isAiGuideModalOpen, setAiGuideModalOpen,
    isSearchOpen, setIsSearchOpen, searchInitialQuery, setSearchInitialQuery,
    isSelectMode, setIsSelectMode, selectedTaskIds, setSelectedTaskIds,
    isMoveModalOpen, setMoveModalOpen, isAiChatOpen, setAiChatOpen,
    aiChatHistory, setAiChatHistory, showAiChatFab, setShowAiChatFab,
    isAiChatLoading, setIsAiChatLoading, isAiDoubtSolverOpen, setIsAiDoubtSolverOpen, 
    isCreateDeckModalOpen, setCreateDeckModalOpen, isAiFlashcardModalOpen, setAiFlashcardModalOpen,
    editingDeck, setEditingDeck, viewingDeck, setViewingDeck,
    isCreateCardModalOpen, setCreateCardModalOpen, editingCard, setEditingCard,
    reviewingDeck, setReviewingDeck, viewingFile, setViewingFile,
    isMusicLibraryOpen, setIsMusicLibraryOpen, analyzingMistake, setAnalyzingMistake,
    handleMoveSelectedTasks, handleSaveDeck, handleDeleteCard, handleSaveCard,
    setDeepLinkAction, isMessagingModalOpen, setMessagingModalOpen, messagingStudent, setMessagingStudent,
    isAnswerKeyUploadModalOpen, setAnswerKeyUploadModalOpen, isProfileModalOpen, setIsProfileModalOpen,
    isSpecificMistakeAnalysisModalOpen, setIsSpecificMistakeAnalysisModalOpen
  ]);


  // Determine main content based on auth state and backend status
  const renderMainContent = () => {
    if (isLoading) {
      return (
        <div className="min-h-screen flex items-center justify-center text-white text-xl">
          <div className="w-8 h-8 border-4 border-cyan-500 border-t-transparent rounded-full animate-spin mr-4"></div>
          Loading app...
        </div>
      );
    }

    if (backendStatus === 'offline') {
      return <BackendOfflineScreen onSelectDemoUser={enterDemoMode} onRetryConnection={checkBackendStatus} backendStatus={backendStatus} />;
    }

    if (backendStatus === 'misconfigured') {
      return <ConfigurationErrorScreen onRetryConnection={checkBackendStatus} backendStatus={backendStatus} />;
    }

    if (!currentUser && !isDemoMode) {
      return <AuthScreen backendStatus={backendStatus} googleClientId={googleClientId} resetToken={resetToken} />;
    }

    if (currentUser && currentUser.CONFIG.settings.examType === undefined) {
      return <ExamTypeSelectionModal onClose={() => { /* no-op for initial selection */ }} onSelect={(type) => handleUpdateConfig({ settings: { ...currentUser.CONFIG.settings, examType: type } })} />;
    }
    
    // Main App Layout
    return (
      <div className={`min-h-screen ${currentUser?.CONFIG.settings.theme === 'liquid-glass' ? 'theme-liquid-glass' : currentUser?.CONFIG.settings.theme === 'midnight' ? 'theme-midnight' : ''}`} >
        <div className="container mx-auto px-4 pt-4 sm:pt-6">
          <Header
            user={{ name: currentUser.fullName, id: currentUser.sid, profilePhoto: currentUser.profilePhoto }}
            onLogout={logout}
            backendStatus={backendStatus}
            isSyncing={isSyncing}
            onOpenProfile={() => openModal('ProfileModal', setIsProfileModalOpen)}
          />
          
          {userRole === 'student' && currentUser ? (
            <StudentDashboard
              student={currentUser}
              onSaveTask={handleSaveTask}
              onSaveBatchTasks={handleSaveBatchTasks}
              onDeleteTask={handleDeleteTask}
              onToggleMistakeFixed={handleToggleMistakeFixed}
              onUpdateConfig={handleUpdateConfig}
              onLogStudySession={handleLogStudySession}
              onUpdateWeaknesses={handleUpdateWeaknesses}
              onLogResult={handleLogResult}
              onAddExam={handleAddExam}
              onUpdateExam={handleUpdateExam}
              onDeleteExam={handleDeleteExam}
              onExportToIcs={handleExportToIcs}
              onBatchImport={handleBatchImport}
              googleAuthStatus={googleAuthStatus}
              onGoogleSignIn={handleGoogleSignIn}
              onGoogleSignOut={handleGoogleSignOut}
              onBackupToDrive={handleBackupToDrive}
              onRestoreFromDrive={handleRestoreFromDrive}
              allDoubts={allDoubts}
              onPostDoubt={handlePostDoubt}
              onPostSolution={handlePostSolution}
              deepLinkAction={deepLinkAction}
              {...modalControlProps}
            />
          ) : userRole === 'admin' && allStudents ? (
            <TeacherDashboard
              students={allStudents}
              onToggleUnacademySub={handleToggleUnacademySub}
              onDeleteUser={handleDeleteStudent}
              onBroadcastTask={handleBroadcastTask}
              onClearData={handleClearStudentData}
              onImpersonate={handleImpersonateStudent}
              {...modalControlProps}
            />
          ) : (
            <div className="text-center text-gray-500 py-10">Initializing dashboard...</div>
          )}
        </div>
        
        {isFullScreenPlayerOpen && <FullScreenMusicPlayer />}
        {currentTrack && <GlobalMusicVisualizer />}
        {currentTrack && !isFullScreenPlayerOpen && (window.innerWidth < 768) && <PersistentMusicPlayer />}
        
        {/* Modals - All rendered at the App level, managed by modalControlProps */}
        {isExamTypeSelectionModalOpen && <ExamTypeSelectionModal onClose={() => closeModal('ExamTypeSelectionModal')} onSelect={(type) => { handleUpdateConfig({ settings: { ...currentUser?.CONFIG.settings, examType: type } }); closeModal('ExamTypeSelectionModal'); }} />}
        {isCreateModalOpen && <CreateEditTaskModal task={editingTask || viewingTask} viewOnly={!!viewingTask} onClose={() => closeModal('CreateEditTaskModal')} onSave={handleSaveTask} decks={currentUser?.CONFIG.flashcardDecks || []} />}
        {isAiParserModalOpen && <AIParserModal onClose={() => closeModal('AIParserModal')} onDataReady={setDeepLinkAction} onPracticeTestReady={setAiPracticeTest} onOpenGuide={() => openModal('AIGuideModal', setAiGuideModalOpen)} examType={currentUser?.CONFIG.settings.examType} />}
        {isPracticeModalOpen && <CustomPracticeModal initialTask={practiceTask} aiPracticeTest={aiPracticeTest} onClose={() => closeModal('CustomPracticeModal')} onSessionComplete={handleLogStudySession} defaultPerQuestionTime={currentUser?.CONFIG.settings.perQuestionTime || 180} onLogResult={handleLogResult} student={currentUser} onUpdateWeaknesses={handleUpdateWeaknesses} onSaveTask={handleSaveTask} />}
        {isSettingsModalOpen && <SettingsModal settings={currentUser?.CONFIG.settings} decks={currentUser?.CONFIG.flashcardDecks || []} onClose={() => closeModal('SettingsModal')} onSave={handleUpdateConfig} onExportToIcs={handleExportToIcs} googleAuthStatus={googleAuthStatus} onGoogleSignIn={handleGoogleSignIn} onGoogleSignOut={handleGoogleSignOut} onBackupToDrive={handleBackupToDrive} onRestoreFromDrive={handleRestoreFromDrive} onApiKeySet={() => setShowAiChatFab(true)} onOpenAssistantGuide={() => openModal('GoogleAssistantGuideModal', setAssistantGuideOpen)} onOpenAiGuide={() => openModal('AIGuideModal', setAiGuideModalOpen)} onClearAllSchedule={handleClearAllSchedule} onToggleEditLayout={() => handleUpdateConfig({ settings: { ...currentUser?.CONFIG.settings, dashboardLayout: currentUser?.CONFIG.settings.dashboardLayout || [] } })} />}
        {isEditWeaknessesModalOpen && <EditWeaknessesModal currentWeaknesses={currentUser?.CONFIG.WEAK || []} onClose={() => closeModal('EditWeaknessesModal')} onSave={handleUpdateWeaknesses} />}
        {isLogResultModalOpen && <LogResultModal onClose={() => closeModal('LogResultModal')} onSave={handleLogResult} initialScore={initialScoreForModal} initialMistakes={initialMistakesForModal} />}
        {isEditResultModalOpen && editingResult && <EditResultModal result={editingResult} onClose={() => closeModal('EditResultModal')} onSave={handleLogResult} />}
        {isExamModalOpen && <CreateEditExamModal exam={editingExam} onClose={() => closeModal('CreateEditExamModal')} onSave={(exam) => editingExam ? handleUpdateExam(exam) : handleAddExam(exam)} />}
        {isAiMistakeModalOpen && <AIMistakeAnalysisModal onClose={() => closeModal('AIMistakeAnalysisModal')} onSaveWeakness={handleUpdateWeaknesses} />}
        {isAiDoubtSolverOpen && <AIDoubtSolverModal onClose={() => closeModal('AIDoubtSolverModal')} />}
        {isAiChatOpen && <AIChatPopup history={aiChatHistory} onSendMessage={(p, img) => api.aiChat({ history: aiChatHistory, prompt: p, imageBase64: img, domain: window.location.origin }).then(res => setAiChatHistory(prev => [...prev, res])).catch(e => setAiChatHistory(prev => [...prev, { role: 'model', parts: [{ text: `Error: ${e.message}` }] }]))} onClose={() => closeModal('AIChatPopup')} isLoading={isAiChatLoading} />}
        {viewingReport && <TestReportModal result={viewingReport} onClose={() => closeModal('TestReportModal')} onUpdateWeaknesses={handleUpdateWeaknesses} student={currentUser} onSaveDeck={handleSaveDeck} />}
        {isMoveModalOpen && <MoveTasksModal onClose={() => closeModal('MoveTasksModal')} onConfirm={handleMoveSelectedTasks} selectedCount={selectedTaskIds.length} />}
        {isMusicLibraryOpen && <MusicLibraryModal onClose={() => closeModal('MusicLibraryModal')} />}
        {deepLinkAction && <DeepLinkConfirmationModal data={deepLinkAction.data} onClose={() => closeModal('DeepLinkConfirmationModal')} onConfirm={() => handleBatchImport(deepLinkAction.data)} />}

        {/* Flashcard Modals */}
        {isCreateDeckModalOpen && <CreateEditDeckModal deck={editingDeck} onClose={() => closeModal('CreateEditDeckModal')} onSave={handleSaveDeck} />}
        {isAiFlashcardModalOpen && <AIGenerateFlashcardsModal student={currentUser} onClose={() => closeModal('AIGenerateFlashcardsModal')} onSaveDeck={handleSaveDeck} />}
        {viewingDeck && <DeckViewModal deck={viewingDeck} onClose={() => closeModal('DeckViewModal')} onAddCard={() => openModal('CreateEditFlashcardModal', setCreateCardModalOpen)} onEditCard={(card) => { setEditingCard(card); openModal('CreateEditFlashcardModal', setCreateCardModalOpen); }} onDeleteCard={handleDeleteCard} onStartReview={() => openModal('FlashcardReviewModal', setReviewingDeck, viewingDeck)} />}
        {isCreateCardModalOpen && viewingDeck && <CreateEditFlashcardModal card={editingCard} deckId={viewingDeck.id} onClose={() => closeModal('CreateEditFlashcardModal')} onSave={handleSaveCard} />}
        {reviewingDeck && <FlashcardReviewModal deck={reviewingDeck} onClose={() => closeModal('FlashcardReviewModal')} />}
        
        {/* Study Material Modal */}
        {viewingFile && <FileViewerModal file={viewingFile} onClose={() => closeModal('FileViewerModal')} />}

        {/* Assistant & AI Guide Modals */}
        {isAssistantGuideOpen && <GoogleAssistantGuideModal onClose={() => closeModal('GoogleAssistantGuideModal')} />}
        {isAiGuideModalOpen && <AIGuideModal onClose={() => closeModal('AIGuideModal')} examType={currentUser?.CONFIG.settings.examType} />}
        {isMessagingModalOpen && messagingStudent && <MessagingModal student={messagingStudent} onClose={() => closeModal('MessagingModal')} isDemoMode={isDemoMode} />}
        {isAnswerKeyUploadModalOpen && <AnswerKeyUploadModal onClose={() => closeModal('AnswerKeyUploadModal')} onGrade={() => { /* Graded in McqTimer, this modal is only for input */ }} />}
        {isProfileModalOpen && <ProfileModal user={currentUser} onClose={() => closeModal('ProfileModal')} />}
        {isSpecificMistakeAnalysisModalOpen && analyzingMistake !== null && <SpecificMistakeAnalysisModal questionNumber={analyzingMistake} onClose={() => closeModal('SpecificMistakeAnalysisModal')} onSaveWeakness={handleUpdateWeaknesses} />}
        {isSearchOpen && <UniversalSearch isOpen={isSearchOpen} onClose={() => closeModal('UniversalSearch')} onNavigate={(tab) => { /* Logic to navigate tabs in StudentDashboard */}} onAction={() => { /* Logic to perform actions */}} scheduleItems={currentUser?.SCHEDULE_ITEMS || []} exams={currentUser?.EXAMS || []} decks={currentUser?.CONFIG.flashcardDecks || []} initialQuery={searchInitialQuery || undefined} />}

      </div>
    );
  };

export default App;